VFDLRAPACC ;DSS/JDB/RAF - AP accession ; 8/15/12 4:49pm
 ;;2013.1;VENDOR - DOCUMENT STORAGE SYS;**16**;;Build 2
 ;Copyright 1995-2014,Document Storage Systems Inc. All Rights Reserved
 ;VFD LAB ENHANCE 2012.0
 ;
 Q
 ;
 ;
MAIN(SUBS) ;
 ; AP accessioning
 ; Note: All AP and MI tests should be accessioned individually
 ; so that each test has its own entry in File #63.
 ; Inputs
 ;  SUBS:<opt> String of AP subscripts to accept.  dflt="^CY^EM^SP^"
 N VFDABORT,X,Y
 S SUBS=$G(SUBS)
 I SUBS="" S SUBS="^CY^EM^SP^"
 S VFDABORT=0
 F  D  Q:VFDABORT
 . N DATA,DIERR,IENS,OUT,R69,R6901,UID
 . N VFDACCIN,VFDLON,VFDLONINFO,VFDLRVAL,VFDMSG
 . N VFDR60,VFDR6903
 . S VFDABORT=0
 . D CLEAN^DILF
 . S X=$$ASKLON(.VFDABORT)
 . I VFDABORT Q
 . I 'X Q
 . S VFDLON=X
 . K DATA
 . S X=$$ASKTST(VFDLON,SUBS,"",.DATA,.VFDABORT)
 . I VFDABORT Q
 . I 'X Q
 . S VFDR60=+X
 . K X
 . S X(VFDR60)=""
 . D LONINFO(VFDLON,.X,.VFDLONINFO)
 . K X
 . I '$D(VFDLONINFO(2,VFDR60)) D  Q
 . . W !!,"   Not a valid Order #/test combination.",!! H 1
 . ;
 . ; DATA from $$ASKTST
 . S R69=+$G(DATA(69))
 . S R6901=+$G(DATA(69.01))
 . S VFDR6903=+$G(DATA(69.03))
 . K DATA
 . S VFDACCIN(69)=R69
 . S VFDACCIN(69.01)=R6901
 . S VFDACCIN(69.03)=VFDR6903
 . S X=$$OK2ACC^VFDLRU02(R69,R6901,VFDR6903)
 . I 'X D  Q  ;
 . . W !!,"Test ",$P(X,"^",3,99)
 . ;
 . D DISPORD(R69,R6901,VFDR6903)
 . K DIR,Y
 . S DIR(0)="Y"
 . S DIR("A")="Is this the correct order"
 . S DIR("B")="NO"
 . D ^DIR
 . I $D(DTOUT)!$D(DUOUT) S VFDABORT=1 Q
 . I Y=0 Q
 . ;coll date
 . S DATA=$G(^LRO(69,R69,1,R6901,1))
 . S X=$P(DATA,U,1)
 . I X D  ;
 . . W !,"Collection Date/Time: ",$$FMTE^XLFDT(X)
 . E  D  ;
 . . S X=$$ASKCOLL(.VFDABORT)
 . . I VFDABORT Q
 . . I 'X Q
 . ;
 . S VFDACCIN("COLLDT")=X
 . ;Lab Arrival DT
 . S DATA=$G(^LRO(69,R69,1,R6901,3))
 . S X=$P(DATA,U,1)
 . ;DSS/RAF - BEGIN MOD - add prompt for Collected By and store results.
 . I $G(^%ZOSF("ZVX"))["VX",$$GET^XPAR("SYS","VFD LAB ASK COLLECTING PERSON") D
 . . D VFD^LROE  ;sets VFDCDUZ=DUZ of collecting person to be used in LRWLST1 later on
 . ;DSS/RAF - END MOD
 . I X D  ;
 . . W !,"Lab Arrival Date/Time: ",$$FMTE^XLFDT(X)
 . E  S X=$$ASKARDT(.VFDABORT)
 . ;
 . I VFDABORT Q
 . I 'X Q
 . S VFDACCIN("ARRDT")=X
 . K DIR,Y
 . S DIR(0)="Y"
 . S DIR("A")="Continue accessioning this test"
 . S DIR("B")="NO"
 . W !
 . D ^DIR
 . I $D(DTOUT)!$D(DUOUT) S VFDABORT=1 Q
 . I Y=0 Q
 . ; make call to create a new accession
 . K VFDLRVAL
 . S X=$$ACC1AP^VFDLROEAP(.VFDACCIN,.VFDLRVAL)
 . I 'X D  Q  ;
 . . W !,$C(7),"  Error during accessioning:"
 . . W !,"    ",$P(X,"^",3)
 . . H 2
 . ;
 . S UID=$G(VFDLRVAL(VFDR6903))
 . I UID="" D  Q  ;
 . . W !,$C(7),"  Error:   No UID created."
 . . H 2
 . ;
 . ; Update #63
 . W !!,"  Accession's UID: "_UID,!!
 . S X=$$AP63(VFDR60,UID,,.VFDABORT)
 . I 'X D  ;
 . . W !!,$C(7),"An error occurred during LAB DATA entry:"
 . . W !,"  ",$P(X,"^",3,99)
 . ;
 . ; print accession label
 . K DIR,Y
 . S DIR(0)="Y"
 . S DIR("A")="Print label"
 . S DIR("B")="YES"
 . D ^DIR
 . I $D(DTOUT)!$D(DUOUT) S VFDABORT=1 Q
 . I Y=1 D  ;
 . . N LRI,LRLABX,LRN
 . . D EN^VFDLRLABXT(UID)
 . ;
 . K DATA
 . D TSTSLEFT(VFDLON,.DATA)
 . D SHOTSTS(.DATA)
 . W !
 ;
 D CLEAN^DILF
 Q
 ;
 ;
DISPORD(R69,R6901,R6903,VFDORDINFO) ;
 ; Display order info.
 ; Inputs
 ;  R69: #69 ien
 ;  R6901: #69.01 ien
 ;  R6903: #69.03 ien
 ;  VFDORDINFO:<byref><opt>  See Outputs
 ; Outputs
 ;  Data array generated by ORDINFO API
 N AGE,DFN,DOB,DOD,LRDFN,LRDPF,LREND,LRPRAC,LRRB,LRTREA,LRWRD
 N PNM,SEX,SSN,VA,VA200,VADM,VAERR,VAIN,X
 S R69=+$G(R69)
 S R6901=+$G(R6901)
 S R6903=+$G(R6903)
 K VFDORDINFO
 D ORDINFO(R69,R6901,R6903,.VFDORDINFO)
 S LRDFN=$G(VFDORDINFO(69.01,.01,"I"))
 S X=$G(^LR(LRDFN,0))
 S DFN=$P(X,U,3)
 S LRDPF=$P(X,U,2)
 D PT^LRX
 W !!
 W !,PNM
 W ?35,$$LABEL^VFDLRU02(),": ",$G(SSN)
 W !,?35,"DOB: ",$$FMTE^XLFDT($G(DOB))
 W !,"Requesting Location: ",$G(VFDORDINFO(69.01,8,"E"))
 W !,"Date/Time Ordered: ",$G(VFDORDINFO(69.01,5,"E"))
 W ?42,"By: ",$G(VFDORDINFO(69.01,1,"E"))
 W !,"Lab Order #: ",$G(VFDORDINFO(69.01,9.5,"E"))
 W ?36,"Provider: ",$G(VFDORDINFO(69.01,7,"E"))
 W !,$G(VFDORDINFO(69.01,3,"E"))_"   "
 W $G(VFDORDINFO(69.02,.01,"E"))
 W !,$G(VFDORDINFO(69.03,.01,"E"))
 W ?35,$G(VFDORDINFO(69.03,1,"E"))
 W ?48,"OERR #: ",$G(VFDORDINFO(69.03,6,"E"))
 W !,$G(VFDORDINFO(69.01,4,"E"))
 W ?35,"Requested For ",$G(VFDORDINFO(69.01,5.5,"E"))
 W !
 D KVAR^VADPT
 Q
 ;
 ;
ASKLON(ABORT) ;
 ; Ask Lab Order #
 ; Inputs
 ;   ABORT:<byref> See Outputs
 ; Outputs
 ;   ABORT: Set to 1 if user aborts or times out.
 N X,Y
 S Y=0
 F  D  Q:Y  Q:ABORT  ;
 . N DIR
 . S DIR(0)="NAO^1::0"
 . S DIR("?")="Enter a number between 1 and 999999999999"
 . S DIR("A")="Enter Lab Order #: "
 . D ^DIR
 . I Y="^" S ABORT=1 Q
 . I 'Y!$D(DTOUT)!$D(DUOUT) S ABORT=1 Q
 . I $D(^LRO(69,"C",+Y)) Q
 . S Y=0
 . W !,$C(7),"  Invalid order number." H 2
 ;
 I ABORT Q 0
 Q +Y
 ;
 ;
ASKTST(LON,SUBS,SCREEN,TESTOUT,ABORT) ;
 ; ask for lab test associated with order
 ; Inputs
 ;     LON: Lab Order Number (eg 255)
 ;    SUBS:<opt><dflt="^SP^"> Delimited string of test subscript(s).
 ;  SCREEN:<opt> the DIC("S") setting for test lookup.
 ; TESTOUT:<byref> See Outputs
 ;   ABORT:<byref> See Outputs
 ; Outputs
 ; Returns 0  or  #60^#69^#69.01^#69.03 of selected test
 ; TESTOUT: Data array for the test selected.
 ;        : TESTOUT(60)=#60 ien  TESTOUT(69)=#69 ien
 ;        : TESTOUT(69.01)=#69.01 ien  TESTOUT(69.03)=#69.03 ien
 ;   ABORT: Set to 1 if user aborts or times out.
 N CODES,CNT,DATA,DIR,LONINFO,I,NODE,R60,R69,R6901,R6903
 N SPEC,SS,STOP,VFDR60,X,Y
 S LON=$G(LON)
 S SUBS=$G(SUBS)
 S SCREEN=$G(SCREEN)
 K TESTOUT
 I SUBS="" S SUBS="^SP^CY^EM^"
 D LONINFO(LON,,.LONINFO)
 ; build array of AP tests on order
 S VFDR60=0
 F  S VFDR60=$O(LONINFO(2,VFDR60)) Q:'VFDR60  D  ;
 . S X=$G(^LAB(60,VFDR60,0))
 . S SS=$P(X,U,4)
 . I '$$ISAPSS^VFDLRU02(SS) Q
 . I SUBS'[("^"_SS_"^") Q
 . S VFDR60(VFDR60)=""
 ;
 I '$O(VFDR60(0)) D  Q "0^1^No AP tests on order"  ;
 . W !,$C(7),"  No AP tests on this lab order." H 2
 ;
 ; Remove from array tests that are accessioned or canceled
 S R60=0
 F  S R60=$O(VFDR60(R60)) Q:'R60  D  ;
 . S NODE=$NA(LONINFO(2,R60))
 . F  S NODE=$Q(@NODE) Q:NODE=""  Q:$QS(NODE,1)'=2  Q:$QS(NODE,2)'=R60  D  ;
 . . S R69=+$QS(NODE,3)
 . . S R6901=+$QS(NODE,4)
 . . S R6903=+@NODE
 . . I 'R6903 Q
 . . I '$$OK2ACC^VFDLRU02(R69,R6901,R6903) Q
 . . S VFDR60(R60,R69,R6901,R6903)=""
 . ;
 ;
 ;I '$O(VFDR60(0)) D  Q "0^2^No AP tests need accessioned"  ;
 S STOP=0
 S NODE="VFDR60(0)"
 F  S NODE=$Q(@NODE)  Q:NODE=""  D  Q:STOP  ;
 . ; any VFDR60(R60,R69,R6901,R6903) nodes defined?
 . I $QL(NODE)>1 S STOP=1
 ;
 I 'STOP D  Q "0^2^No AP tests need accessioned"
 . W !,$C(7),"  No AP tests found needing accessioning." H 2
 ;
 ; Get test name(s) and specimen(s)
 ; VFDR60(R60)=""
 ; VFDR60(R60,R69,R6901,R6903)=""
 ; Builds CODES("C",testName,cnt)=R60_"^"_R69_"^"_R6901_"^"_R6903
 ; to alphabetize test names.
 S NODE="VFDR60(0)"
 S CNT=0
 K CODES
 F  S NODE=$Q(@NODE) Q:NODE=""  D  ;
 . N SPEC,TEST
 . I $QL(NODE)<2 Q
 . S R60=+$QS(NODE,1)
 . S R69=+$QS(NODE,2)
 . S R6901=+$QS(NODE,3)
 . S R6903=+$QS(NODE,4)
 . S DATA=$G(^LAB(60,R60,0))
 . S TEST=$P(DATA,U,1)
 . S X=+$O(^LRO(69,R69,1,R6901,4,0))
 . S DATA=$G(^LRO(69,R69,1,R6901,4,X,0))
 . S X=+$P(DATA,U,1)
 . S DATA=$G(^LAB(61,X,0))
 . S SPEC=$P(DATA,U,1)
 . I $G(SCREEN)'="" X SCREEN I '$T Q
 . S CNT=CNT+1
 . ; protect DIR code characters
 . S X=$TR(TEST,";:","  ")_"   "_$TR(SPEC,";:","  ")
 . S CODES("C",X,CNT)=R60_"^"_R69_"^"_R6901_"^"_R6903
 . ;
 ;
 ; build CODES(i) array
 ;  CODES("C",name,cnt)=R60_"^"_R69_"^"_R6901_"^"_R6903
 ; creates:
 ;  CODES=codes for DIR  (idx:testName;...)
 ;  CODES(idx)=R60_"^"_R69_"^"_R6901_"^"_R6903
 S CNT=0
 S CODES=""
 S NODE="CODES(""C"")"
 F  S NODE=$Q(@NODE) Q:NODE=""  Q:$QS(NODE,1)'="C"  D  ;
 . S X=$QS(NODE,2) ;name
 . S CNT=CNT+1
 . S CODES=CODES_CNT_":"_X_";"
 . S CODES(CNT)=@NODE
 ;
 K CODES("C")
 K DIR
 S DIR(0)="SO^"_CODES
 S DIR("A")="Select Test"
 D ^DIR
 ; Y=selected CODES' index #
 I Y'>0!$D(DTOUT)!$D(DUOUT) S Y=0 S ABORT=1
 I Y>0 D  ;
 . S Y=$G(CODES(Y)) ;sets Y = R60^R69^R6901^R6903
 . S TESTOUT(60)=+$P(Y,"^",1)
 . S TESTOUT(69)=+$P(Y,"^",2)
 . S TESTOUT(69.01)=+$P(Y,"^",3)
 . S TESTOUT(69.03)=+$P(Y,"^",4)
 ;
 Q Y
 ;
 ;
ASKCOLL(ABORT) ;
 ;
 ; Inputs
 ;   ABORT:<byref> See Outputs
 ; Outputs
 ;   ABORT: Set to 1 if user aborts or times out.
 N DIR,X,Y
 S DIR(0)="DA^::ETR"
 S DIR("A")="Enter Collection Date/Time: "
 S DIR("?")="Enter the date and time the sample was collected."
 D ^DIR
 I $D(DTOUT)!$D(DUOUT) S ABORT=1
 Q +Y
 ;
 ;
ASKARDT(ABORT) ;
 ;
 ; Inputs
 ;   ABORT:<byref> See Outputs
 ; Outputs
 ;   ABORT: Set to 1 if user aborts or times out.
 N DIR,X,Y
 S DIR(0)="DA^::ETR"
 S DIR("A")="Enter Lab Arrival Date/Time: "
 S DIR("?")="Enter the date and time the sample was received in the Laboratory."
 D ^DIR
 I $D(DTOUT)!$D(DUOUT) S ABORT=1
 Q +Y
 ;
 ;
ASKSUBBY(DFLT,ABORT) ;
 ;
 ; Inputs
 ;    DFLT:<opt> The default value to display.
 ;   ABORT:<byref> See Outputs
 ; Outputs
 ;   ABORT: Set to 1 if user aborts or times out.
 N DIC,DIR,DLAYGO,X,Y
 S DFLT=$G(DFLT)
 S DIC=200
 S DIC(0)="AEQVZ"
 S DIC("A")="Specimen submitted by: "
 I DFLT'="" S DIC("B")=DFLT
 D ^DIC
 I Y>0 Q $E(Y(0,0),1,30)
 I DFLT="" I $D(DTOUT)!$D(DUOUT) S ABORT=1 Q ""
 E  I $D(DTOUT) S ABORT=1 Q ""
 K DIR
 S DIR(0)="Y"
 S DIR("A")="Enter a free text name"
 S DIR("B")="NO"
 D ^DIR
 I Y=0 Q ""
 I 'Y S ABORT=1 Q ""
 I $D(DTOUT)!$D(DUOUT) S ABORT=1 Q ""
 K DIR
 S DIR(0)="FA^1:30"
 S DIR("?")="Enter between 1 and 30 characters"
 S DIR("A")="Specimen submitted by: "
 D ^DIR
 I $D(DTOUT)!$D(DUOUT) S ABORT=1
 Q $$TRIM^XLFSTR(Y)
 ;
 ;
ORDINFO(R69,R6901,R6903,VFDOUT) ;
 ; Retrieve order info
 ; Inputs
 ;  R69: #69 ien
 ;  R6901: #69.01 ien
 ;  R6903: #69.03 ien
 ;  VFDOUT:<byref>  See Outputs
 ; Outputs:
 ;   VFDOUT(69.01,fld#,"E")=external value
 ;   VFDOUT(69.01,fld#,"I")=internal value
 ;   VFDOUT(69.02,fld#,"E")=external value
 ;   VFDOUT(69.02,fld#,"I")=internal value
 ;   VFDOUT(69.03,fld#,"E")=external value
 ;   VFDOUT(69.03,fld#,"I")=internal value
 N DATA,DIERR,I,IENS,VFDM,VFDERR
 S R69=+$G(R69)
 S R6901=+$G(R6901)
 S R6903=+$G(R6903)
 K IENS,VFDM,VFDERR,VFDOUT
 S IENS=R6901_","_R69_","
 D GETS^DIQ(69.01,IENS,".01;1;3;4;5;5.5;7;8;9.5","IE","VFDM","VFDERR")
 K DATA
 M DATA(69.01)=VFDM(69.01,IENS)
 K VFDM
 M VFDOUT(69.01)=DATA(69.01)
 K DATA,IENS,VFDM,VFDERR
 S IENS=R6903_","_R6901_","_R69_","
 D GETS^DIQ(69.03,IENS,".01;1;6","EI","VFDM","VFDERR")
 K DATA
 M DATA(69.03)=VFDM(69.03,IENS)
 K VFDM
 M VFDOUT(69.03)=DATA(69.03)
 K DATA
 S X=+$O(^LRO(69,R69,1,R6901,4,0))
 S IENS=X_","_R6901_","_R69_","
 K VFDM
 D GETS^DIQ(69.02,IENS,".01;@","EI","VFDM","VFDERR")
 K DATA
 M DATA(69.02)=VFDM(69.02,IENS)
 K VFDM
 M VFDOUT(69.02)=DATA(69.02)
 K DATA
 D CLEAN^DILF
 Q
 ;
 ;
LONINFO(LON,TESTS,OUT) ;
 ; Retrieve info for a Lab Order #
 ; Inputs
 ;    LON:  Lab Order #
 ;  TESTS:<byref><opt> Array of #60 IENs to find.  If undefined
 ;       : returns info for all tests in 69.   TESTS(22)=""
 ;   OUT:<byref>  See Outputs
 ; Outputs
 ;  OUT array
 ;   OUT(1,R69,R6901,R60)=R6903
 ;   OUT(2,R60,R69,R6901)=R6903
 N I,NODE,R60,R69,R6901,R6903,STOP,X
 S LON=$G(LON)
 K OUT
 S STOP=0
 S (NODE,NODE(0))=$NA(^LRO(69,"C",LON))
 F  S NODE=$Q(@NODE) Q:NODE=""  D  Q:STOP
 . F I=1:1:3 I $QS(NODE,I)'=$QS(NODE(0),I) S STOP=1 Q
 . I STOP Q
 . S R69=$QS(NODE,4)
 . S R6901=$QS(NODE,5)
 . I 'R6901 Q
 . I $D(TESTS) D  Q  ;
 . . S R60=0
 . . F  S R60=$O(TESTS(R60)) Q:'R60  D  ;
 . . . S R6903=+$O(^LRO(69,R69,1,R6901,2,"B",R60,0))
 . . . I 'R6903 Q
 . . . I $D(OUT(2,R60,R69,R6901)) Q
 . . . S OUT(1,R69,R6901,R60)=R6903
 . . . S OUT(2,R60,R69,R6901)=R6903
 . . ;
 . S R6903=0
 . F  S R6903=$O(^LRO(69,R69,1,R6901,2,R6903)) Q:'R6903  D  ;
 . . S X=$G(^LRO(69,R69,1,R6901,2,R6903,0))
 . . S R60=$P(X,U,1)
 . . I 'R60 Q
 . . I $D(OUT(2,R60,R69,R6901)) Q
 . . S OUT(1,R69,R6901,R60)=R6903
 . . S OUT(2,R60,R69,R6901)=R6903
 . ;
 ;
 Q
 ;
 ;
AP63(R60,UID,VFDIN,VFDABORT,VFDERR) ;
 ; Files additional fields for AP test into File #63.
 ; Call after test is accessioned.
 ; Inputs
 ;       R60: #60 ien
 ;       UID: UID
 ;     VFDIN:<byref><opt> Additional parameters if needed.
 ;  VFDABORT:<byref> See Outputs below
 ;    VFDERR:<byref> See Outputs below
 ; Outputs
 ;  Returns 1  or  0^errNum^errMsg
 ;   VFDABORT: Returns 1 if user times out or ^.
 ;     VFDERR: The error array from FileMan FILE^DIE call.
 N DA,DATA,DIC,DIE,DIERR,DLAYGO,DR,FDA,FILE,IEN
 N LRC,LRDFN,LRIDT,LRLLOC,LROLLOC,LRORD
 N LRORIFN,LRPRAC,LRSAMP,LRSPEC,LRSS
 N R68,R6801,R6802,R69,R6901,R6903,VFDX,X,Y
 S R60=+$G(R60)
 S UID=$G(UID)
 K VFDERR
 D F68TO63^VFDLRU02(UID,,,,.DATA)
 S R68=+$G(DATA(68))
 S R6801=+$G(DATA(68.01))
 S R6802=+$G(DATA(68.02))
 S LRDFN=+$G(DATA("LRDFN"))
 S LRSS=$G(DATA("LRSS"))
 S LRIDT=$G(DATA("LRIDT"))
 I 'LRDFN Q
 I '$$ISAPSS^VFDLRU02(LRSS) Q "0^1^Not an AP test"
 K DATA
 D F68TO69^VFDLRU02(R68,R6801,R6802,.DATA)
 S R69=+$G(DATA(69))
 S R6901=+$G(DATA(69.01))
 I 'R6901 Q "0^2^No File #69.01"
 D DATA69^VFDLROEAP(R69,R6901)
 S FILE=$$SS2FILE^VFDLRU02(LRSS)
 K DR
 S DR=".011"
 S IEN=LRIDT_","_LRDFN_","
 D  ;
 . N DR
 . K DIERR,VFDERR
 . S X=$$GET1^DIQ(FILE,IEN,.011,"I",,"VFDERR")
 ;
 I X="" D  ;
 . S DR="S VFDX=$$ASKSUBBY^VFDLRAPACC(,.VFDABORT) I $G(VFDABORT) S Y=0;.011///^S X=VFDX"
 ;
 S DATA(60)=R60
 I LRSS="SP" D SP(.DR,"",.VFDABORT)
 I LRSS="CY" D CY(.DR,.DATA,.VFDABORT)
 I LRSS="EM" D EM(.DR,"",.VFDABORT)
 S DIE="^LR("_LRDFN_","""_LRSS_""","
 K DA
 S DA=LRIDT
 S DA(1)=LRSS
 S DA(2)=LRDFN
 S DIE("NO^")="BACK"
 K X
 D ^DIE
 D CLEAN^DILF
 Q 1
 ;
 ;
CY(DR,VFDIN,VFDABORT) ;
 ; Setup DIE DR string for CY
 ; Inputs
 ;        DR:<byref> FileMan DIE's DR string (See Outputs)
 ;     VFDIN:<byref> Array to pass input parameters.
 ;  VFDABORT:<byref>  See Outputs
 ; Outputs
 ;   Sets the DR array.
 ;   If User ^ arrows out, VFDABORT is set.
 N R60
 S DR=$G(DR)
 S R60=+$G(VFDIN(60))
 S DR=DR_";.012"
 I $G(LRSPEC) D  ;
 . N X
 . S X=$G(^LAB(61,+LRSPEC,0))
 . S X=$P(X,U,1)
 . S DR=DR_"//"_X
 ;
 S DR=DR_";.02;.99;S LRC(5)=X;1"
 S DR(2,63.902)=".01;.02"
 I R60 S DR(2,63.902)=DR(2,63.902)_"////"_R60
 Q
 ;
 ;
EM(DR,VFDIN,VFDABORT) ;
 ; Setup DIE DR string for EM
 ; Inputs
 ;        DR:<byref> FileMan DIE's DR string (See Outputs)
 ;     VFDIN:<byref> Array to pass input parameters.
 ;  VFDABORT:<byref>  See Outputs
 ; Outputs
 ;   Sets the DR array.
 ;   If User ^ arrows out, VFDABORT is set.
 S DR=$G(DR)
 S DR=DR_";.012"
 I $G(LRSPEC) D  ;
 . N X
 . S X=$G(^LAB(61,+LRSPEC,0))
 . S X=$P(X,U,1)
 . S DR=DR_"//"_X
 ;
 S DR=DR_";.02;.021;.99;S LRC(5)=X"
 S DR(2,63.202)=.01
 Q
 ;
 ;
SP(DR,VFDIN,VFDABORT) ;
 ; Fields asked are from routine SP^LRAP
 ; Setup DIE DR string for SP
 ; Inputs
 ;        DR:<byref> FileMan DIE's DR string (See Outputs)
 ;     VFDIN:<byref> Array to pass input parameters.
 ;  VFDABORT:<byref>  See Outputs
 ; Outputs
 ;   Sets the DR array.
 ;   If User ^ arrows out, VFDABORT is set to 1.
 S DR=$G(DR)
 S DR=DR_";.012"
 I $G(LRSPEC) D  ;
 . N X
 . S X=$G(^LAB(61,+LRSPEC,0))
 . S X=$P(X,U,1)
 . S DR=DR_"//"_X
 ;
 S DR=DR_";.02;.99;S LRC(5)=X;1.3"
 S DR(2,63.812)=.01
 Q
 ;
 ;
TSTSLEFT(LON,OUT) ;
 ; Get the remaining AP tests left on the lab order
 ; Inputs
 ;   LON: Lab Order Number
 ;   OUT:<byref>  Array of AP #60 iens left on order.  eg OUT(#60)=""
 ; Outputs
 ;   OUT:  Array of AP test left on order
 ;      :  OUT(#60,#69,#69.01,#69.03)
 ;
 N DATA,NODE,R60,R69,R6901,R6903,SS,TESTS,UID,X
 S LON=$G(LON)
 K OUT
 D LONINFO(LON,,.TESTS)
 S NODE="TESTS(2,0)"
 F  S NODE=$Q(@NODE) Q:NODE=""  Q:$QS(NODE,1)'=2  D  ;
 . S R60=+$QS(NODE,2)
 . S R69=+$QS(NODE,3)
 . S R6901=+$QS(NODE,4)
 . S R6903=+@NODE
 . S DATA=$G(^LAB(60,R60,0))
 . S SS=$P(DATA,U,4)
 . I '$$ISAPSS^VFDLRU02(SS) Q
 . I '$$OK2ACC^VFDLRU02(R69,R6901,R6903) Q
 . S OUT(R60,R69,R6901,R6903)=""
 ;
 Q
 ;
 ;
SHOTSTS(IN) ;
 ; Display the tests left on the order
 ; Inputs
 ;   IN:<byref>  Array of #60 iens for AP tests on order  (IN(n)="")
 N DATA,R60,SS,X
 I '$O(IN(0)) D  Q  ;
 . W !!,"  No AP tests left for accessioning on this lab order." H 2
 ;
 W !!," The following AP tests have not been accessioned on this lab order:"
 S R60=0
 F  S R60=$O(IN(R60)) Q:'R60  D  ;
 . S DATA=$G(^LAB(60,R60,0))
 . S X=$P(DATA,U,1)
 . S SS=$P(DATA,U,4)
 . W !?5,SS,?12,X
 ;
 Q
